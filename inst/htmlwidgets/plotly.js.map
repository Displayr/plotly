{"version":3,"sources":["node_modules/browser-pack/_prelude.js","theSrc/scripts/plotly.js","theSrc/scripts/widgetdefinition.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","_widgetdefinition","HTMLWidgets","widget","_widgetdefinition2","default","widgetDefinition","name","type","initialize","el","width","height","resize","instance","autosize","Plotly","relayout","renderValue","x","lay","layout","crosstalk","var","set","highlight","window","PLOTLYENV","BASE_URL","base_url","persistent","onmousemove","event","shiftKey","persistentShift","graphDiv","document","getElementById","id","addPostRenderHandler","modebars","querySelectorAll","style","zIndex","selectize","dynamic","plotly","pickerDiv","flex","createElement","class","pickerInput","placeholder","pickerLabel","for","innerHTML","appendChild","ids","Object","keys","container","label","group","selectDiv","select","multiple","parentElement","insertBefore","picker","$","colors","color","opts","value","showColour","palette","allowedCols","join","colourpicker","changeDelay","grps","ctGroups","on","eventDataWithKey","eventData","undefined","hasOwnProperty","points","map","pt","obj","curveNumber","pointNumber","y","z","customdata","attrsToAttach","trace","data","_isSimpleKey","key","attr","Array","isArray","pointNumbers","idx","purge","plot","then","shinyMode","Shiny","addCustomMessageHandler","msg","gd","method","args","concat","apply","react","mapboxIDs","_fullLayout","_subplots","mapbox","_fitBounds","_subplot","fitBounds","bounds","options","eventClearMap","eventDataFunctionMap","legendEventData","d","legendgroup","legendgrps","traces","push","setInputValue","plotly_deselect","plotly_unhover","plotly_doubleclick","evt","input","source","priority","plotly_click","plotly_sunburstclick","plotly_hover","plotly_selected","plotly_selecting","plotly_brushed","range","lassoPoints","plotly_brushing","plotly_legendclick","plotly_legenddoubleclick","plotly_clickannotation","fullAnnotation","shinyEvents","eventDataPreProcessor","JSON","stringify","traceManager","TraceManager","allSets","curveIdx","newSet","indexOf","selection","SelectionHandle","FilterHandle","removeBrush","updateFilter","prototype","diff","this","filter","oldValue","selectionHistory","get","receiverID","plotlySelectionColour","ev","updateSelection","clear","addItems","close","selectizeID","turnOn","selectedKeys","keysBySet","keyFlat","ptNum","_isNestedKey","pointsToKeys","sender","debounce","func","wait","immediate","timeout","context","arguments","callNow","clearTimeout","setTimeout","off","items","searchField","valueField","labelField","maxItems","find","currentItems","groupSelections","removeItem","newItems","origData","parse","origOpacity","opacity","getMatchFunc","findNestedMatches","findSimpleMatches","findMatches","haystack","needleSet","matches","forEach","every","val","subsetArrayAttrs","indices","newObj","k","charAt","transform","toString","getPrototypeOf","arr","result","subsetArray","outlines","remove","matchFunc","redraw","nNewTraces","tracesToRemove","_isCrosstalkTrace","deleteTraces","restyle","selectionColour","_fullData","extend","selected","marker","line","textfont","fillcolor","_originalIndex","_newIndex","addTraces","_hash","_transitionData","_frameHash","_frames","newIndices","j","tr","ctr","nFrameTraces","frameTrace","tracesToDim","opacities","sets","opacityDim","selectedpoints"],"mappings":"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","file":"plotly.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import widgetDefinition from './widgetdefinition'\n\nHTMLWidgets.widget(widgetDefinition)\n","const widgetDefinition = {\n  name: \"plotly\",\n  type: \"output\",\n\n  initialize: function(el, width, height) {\n    return {};\n  },\n\n  resize: function(el, width, height, instance) {\n    if (instance.autosize) {\n      var width = instance.width || width;\n      var height = instance.height || height;\n      Plotly.relayout(el, {width: width, height: height});\n    }\n  },\n  \n  renderValue: function(el, x, instance) {\n    \n    // Plotly.relayout() mutates the plot input object, so make sure to \n    // keep a reference to the user-supplied width/height *before*\n    // we call Plotly.plot();\n    var lay = x.layout || {};\n    instance.width = lay.width;\n    instance.height = lay.height;\n    instance.autosize = lay.autosize || true;\n    \n    /* \n    / 'inform the world' about highlighting options this is so other\n    / crosstalk libraries have a chance to respond to special settings \n    / such as persistent selection. \n    / AFAIK, leaflet is the only library with such intergration\n    / https://github.com/rstudio/leaflet/pull/346/files#diff-ad0c2d51ce5fdf8c90c7395b102f4265R154\n    */\n    var ctConfig = crosstalk.var('plotlyCrosstalkOpts').set(x.highlight);\n      \n    if (typeof(window) !== \"undefined\") {\n      // make sure plots don't get created outside the network (for on-prem)\n      window.PLOTLYENV = window.PLOTLYENV || {};\n      window.PLOTLYENV.BASE_URL = x.base_url;\n      \n      // Enable persistent selection when shift key is down\n      // https://stackoverflow.com/questions/1828613/check-if-a-key-is-down\n      var persistOnShift = function(e) {\n        if (!e) window.event;\n        if (e.shiftKey) { \n          x.highlight.persistent = true; \n          x.highlight.persistentShift = true;\n        } else {\n          x.highlight.persistent = false; \n          x.highlight.persistentShift = false;\n        }\n      };\n      \n      // Only relevant if we haven't forced persistent mode at command line\n      if (!x.highlight.persistent) {\n        window.onmousemove = persistOnShift;\n      }\n    }\n\n    var graphDiv = document.getElementById(el.id);\n    \n    // TODO: move the control panel injection strategy inside here...\n    HTMLWidgets.addPostRenderHandler(function() {\n      \n      // lower the z-index of the modebar to prevent it from highjacking hover\n      // (TODO: do this via CSS?)\n      // https://github.com/ropensci/plotly/issues/956\n      // https://www.w3schools.com/jsref/prop_style_zindex.asp\n      var modebars = document.querySelectorAll(\".js-plotly-plot .plotly .modebar\");\n      for (var i = 0; i < modebars.length; i++) {\n        modebars[i].style.zIndex = 1;\n      }\n    });\n      \n      // inject a \"control panel\" holding selectize/dynamic color widget(s)\n    if ((x.selectize || x.highlight.dynamic) && !instance.plotly) {\n      var flex = document.createElement(\"div\");\n      flex.class = \"plotly-crosstalk-control-panel\";\n      flex.style = \"display: flex; flex-wrap: wrap\";\n      \n      // inject the colourpicker HTML container into the flexbox\n      if (x.highlight.dynamic) {\n        var pickerDiv = document.createElement(\"div\");\n        \n        var pickerInput = document.createElement(\"input\");\n        pickerInput.id = el.id + \"-colourpicker\";\n        pickerInput.placeholder = \"asdasd\";\n        \n        var pickerLabel = document.createElement(\"label\");\n        pickerLabel.for = pickerInput.id;\n        pickerLabel.innerHTML = \"Brush color&nbsp;&nbsp;\";\n        \n        pickerDiv.appendChild(pickerLabel);\n        pickerDiv.appendChild(pickerInput);\n        flex.appendChild(pickerDiv);\n      }\n      \n      // inject selectize HTML containers (one for every crosstalk group)\n      if (x.selectize) {\n        var ids = Object.keys(x.selectize);\n        \n        for (var i = 0; i < ids.length; i++) {\n          var container = document.createElement(\"div\");\n          container.id = ids[i];\n          container.style = \"width: 80%; height: 10%\";\n          container.class = \"form-group crosstalk-input-plotly-highlight\";\n          \n          var label = document.createElement(\"label\");\n          label.for = ids[i];\n          label.innerHTML = x.selectize[ids[i]].group;\n          label.class = \"control-label\";\n          \n          var selectDiv = document.createElement(\"div\");\n          var select = document.createElement(\"select\");\n          select.multiple = true;\n          \n          selectDiv.appendChild(select);\n          container.appendChild(label);\n          container.appendChild(selectDiv);\n          flex.appendChild(container);\n        }\n      }\n      \n      // finally, insert the flexbox inside the htmlwidget container,\n      // but before the plotly graph div\n      graphDiv.parentElement.insertBefore(flex, graphDiv);\n      \n      if (x.highlight.dynamic) {\n        var picker = $(\"#\" + pickerInput.id);\n        var colors = x.highlight.color || [];\n        // TODO: let users specify options?\n        var opts = {\n          value: colors[0],\n          showColour: \"both\",\n          palette: \"limited\",\n          allowedCols: colors.join(\" \"),\n          width: \"20%\",\n          height: \"10%\"\n        };\n        picker.colourpicker({changeDelay: 0});\n        picker.colourpicker(\"settings\", opts);\n        picker.colourpicker(\"value\", opts.value);\n        // inform crosstalk about a change in the current selection colour\n        var grps = x.highlight.ctGroups || [];\n        for (var i = 0; i < grps.length; i++) {\n          crosstalk.group(grps[i]).var('plotlySelectionColour')\n            .set(picker.colourpicker('value'));\n        }\n        picker.on(\"change\", function() {\n          for (var i = 0; i < grps.length; i++) {\n            crosstalk.group(grps[i]).var('plotlySelectionColour')\n              .set(picker.colourpicker('value'));\n          }\n        });\n      }\n    }\n    \n    // if no plot exists yet, create one with a particular configuration\n    if (!instance.plotly) {\n      \n      var plot = Plotly.plot(graphDiv, x);\n      instance.plotly = true;\n      \n    } else {\n      \n      // this is essentially equivalent to Plotly.newPlot(), but avoids creating \n      // a new webgl context\n      // https://github.com/plotly/plotly.js/blob/2b24f9def901831e61282076cf3f835598d56f0e/src/plot_api/plot_api.js#L531-L532\n\n      // TODO: restore crosstalk selections?\n      Plotly.purge(graphDiv);\n      // TODO: why is this necessary to get crosstalk working?\n      graphDiv.data = undefined;\n      graphDiv.layout = undefined;\n      var plot = Plotly.plot(graphDiv, x);\n    }\n    \n    // Trigger plotly.js calls defined via `plotlyProxy()`\n    plot.then(function() {\n      if (HTMLWidgets.shinyMode) {\n        Shiny.addCustomMessageHandler(\"plotly-calls\", function(msg) {\n          var gd = document.getElementById(msg.id);\n          if (!gd) {\n            throw new Error(\"Couldn't find plotly graph with id: \" + msg.id);\n          }\n          // This isn't an official plotly.js method, but it's the only current way to \n          // change just the configuration of a plot \n          // https://community.plot.ly/t/update-config-function/9057\n          if (msg.method == \"reconfig\") {\n            Plotly.react(gd, gd.data, gd.layout, msg.args);\n            return;\n          }\n          if (!Plotly[msg.method]) {\n            throw new Error(\"Unknown method \" + msg.method);\n          }\n          var args = [gd].concat(msg.args);\n          Plotly[msg.method].apply(null, args);\n        });\n      }\n      \n      // plotly's mapbox API doesn't currently support setting bounding boxes\n      // https://www.mapbox.com/mapbox-gl-js/example/fitbounds/\n      // so we do this manually...\n      // TODO: make sure this triggers on a redraw and relayout as well as on initial draw\n      var mapboxIDs = graphDiv._fullLayout._subplots.mapbox || [];\n      for (var i = 0; i < mapboxIDs.length; i++) {\n        var id = mapboxIDs[i];\n        var mapOpts = x.layout[id] || {};\n        var args = mapOpts._fitBounds || {};\n        if (!args) {\n          continue;\n        }\n        var mapObj = graphDiv._fullLayout[id]._subplot.map;\n        mapObj.fitBounds(args.bounds, args.options);\n      }\n      \n    });\n    \n    // Attach attributes (e.g., \"key\", \"z\") to plotly event data\n    function eventDataWithKey(eventData) {\n      if (eventData === undefined || !eventData.hasOwnProperty(\"points\")) {\n        return null;\n      }\n      return eventData.points.map(function(pt) {\n        var obj = {\n          curveNumber: pt.curveNumber, \n          pointNumber: pt.pointNumber, \n          x: pt.x,\n          y: pt.y\n        };\n        \n        // If 'z' is reported with the event data, then use it!\n        if (pt.hasOwnProperty(\"z\")) {\n          obj.z = pt.z;\n        }\n        \n        if (pt.hasOwnProperty(\"customdata\")) {\n          obj.customdata = pt.customdata;\n        }\n        \n        /* \n          TL;DR: (I think) we have to select the graph div (again) to attach keys...\n          \n          Why? Remember that crosstalk will dynamically add/delete traces \n          (see traceManager.prototype.updateSelection() below)\n          For this reason, we can't simply grab keys from x.data (like we did previously)\n          Moreover, we can't use _fullData, since that doesn't include \n          unofficial attributes. It's true that click/hover events fire with \n          pt.data, but drag events don't...\n        */\n        var gd = document.getElementById(el.id);\n        var trace = gd.data[pt.curveNumber];\n        \n        if (!trace._isSimpleKey) {\n          var attrsToAttach = [\"key\"];\n        } else {\n          // simple keys fire the whole key\n          obj.key = trace.key;\n          var attrsToAttach = [];\n        }\n        \n        for (var i = 0; i < attrsToAttach.length; i++) {\n          var attr = trace[attrsToAttach[i]];\n          if (Array.isArray(attr)) {\n            if (typeof pt.pointNumber === \"number\") {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber];\n            } else if (Array.isArray(pt.pointNumber)) {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber[0]][pt.pointNumber[1]];\n            } else if (Array.isArray(pt.pointNumbers)) {\n              obj[attrsToAttach[i]] = pt.pointNumbers.map(function(idx) { return attr[idx]; });\n            }\n          }\n        }\n        return obj;\n      });\n    }\n    \n    \n    var legendEventData = function(d) {\n      // if legendgroup is not relevant just return the trace\n      var trace = d.data[d.curveNumber];\n      if (!trace.legendgroup) return trace;\n      \n      // if legendgroup was specified, return all traces that match the group\n      var legendgrps = d.data.map(function(trace){ return trace.legendgroup; });\n      var traces = [];\n      for (i = 0; i < legendgrps.length; i++) {\n        if (legendgrps[i] == trace.legendgroup) {\n          traces.push(d.data[i]);\n        }\n      }\n      \n      return traces;\n    };\n\n    \n    // send user input event data to shiny\n    if (HTMLWidgets.shinyMode && Shiny.setInputValue) {\n      \n      // Some events clear other input values\n      // TODO: always register these?\n      var eventClearMap = {\n        plotly_deselect: [\"plotly_selected\", \"plotly_selecting\", \"plotly_brushed\", \"plotly_brushing\", \"plotly_click\"],\n        plotly_unhover: [\"plotly_hover\"],\n        plotly_doubleclick: [\"plotly_click\"]\n      };\n    \n      Object.keys(eventClearMap).map(function(evt) {\n        graphDiv.on(evt, function() {\n          var inputsToClear = eventClearMap[evt];\n          inputsToClear.map(function(input) {\n            Shiny.setInputValue(input + \"-\" + x.source, null, {priority: \"event\"});\n          });\n        });\n      });\n      \n      var eventDataFunctionMap = {\n        plotly_click: eventDataWithKey,\n        plotly_sunburstclick: eventDataWithKey,\n        plotly_hover: eventDataWithKey,\n        plotly_unhover: eventDataWithKey,\n        // If 'plotly_selected' has already been fired, and you click\n        // on the plot afterwards, this event fires `undefined`?!?\n        // That might be considered a plotly.js bug, but it doesn't make \n        // sense for this input change to occur if `d` is falsy because,\n        // even in the empty selection case, `d` is truthy (an object),\n        // and the 'plotly_deselect' event will reset this input\n        plotly_selected: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_selecting: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_brushed: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_brushing: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_legendclick: legendEventData,\n        plotly_legenddoubleclick: legendEventData,\n        plotly_clickannotation: function(d) { return d.fullAnnotation }\n      };\n      \n      var registerShinyValue = function(event) {\n        var eventDataPreProcessor = eventDataFunctionMap[event] || function(d) { return d ? d : el.id };\n        // some events are unique to the R package\n        var plotlyJSevent = (event == \"plotly_brushed\") ? \"plotly_selected\" : (event == \"plotly_brushing\") ? \"plotly_selecting\" : event;\n        // register the event\n        graphDiv.on(plotlyJSevent, function(d) {\n          Shiny.setInputValue(\n            event + \"-\" + x.source,\n            JSON.stringify(eventDataPreProcessor(d)),\n            {priority: \"event\"}\n          );\n        });\n      }\n    \n      var shinyEvents = x.shinyEvents || [];\n      shinyEvents.map(registerShinyValue);\n    }\n    \n    // Given an array of {curveNumber: x, pointNumber: y} objects,\n    // return a hash of {\n    //   set1: {value: [key1, key2, ...], _isSimpleKey: false}, \n    //   set2: {value: [key3, key4, ...], _isSimpleKey: false}\n    // }\n    function pointsToKeys(points) {\n      var keysBySet = {};\n      for (var i = 0; i < points.length; i++) {\n        \n        var trace = graphDiv.data[points[i].curveNumber];\n        if (!trace.key || !trace.set) {\n          continue;\n        }\n        \n        // set defaults for this keySet\n        // note that we don't track the nested property (yet) since we always \n        // emit the union -- http://cpsievert.github.io/talks/20161212b/#21\n        keysBySet[trace.set] = keysBySet[trace.set] || {\n          value: [],\n          _isSimpleKey: trace._isSimpleKey\n        };\n        \n        // Use pointNumber by default, but aggregated traces should emit pointNumbers\n        var ptNum = points[i].pointNumber;\n        var hasPtNum = typeof ptNum === \"number\";\n        var ptNum = hasPtNum ? ptNum : points[i].pointNumbers;\n        \n        // selecting a point of a \"simple\" trace means: select the \n        // entire key attached to this trace, which is useful for,\n        // say clicking on a fitted line to select corresponding observations \n        var key = trace._isSimpleKey ? trace.key : Array.isArray(ptNum) ? ptNum.map(function(idx) { return trace.key[idx]; }) : trace.key[ptNum];\n        // http://stackoverflow.com/questions/10865025/merge-flatten-an-array-of-arrays-in-javascript\n        var keyFlat = trace._isNestedKey ? [].concat.apply([], key) : key;\n        \n        // TODO: better to only add new values?\n        keysBySet[trace.set].value = keysBySet[trace.set].value.concat(keyFlat);\n      }\n      \n      return keysBySet;\n    }\n    \n    \n    x.highlight.color = x.highlight.color || [];\n    // make sure highlight color is an array\n    if (!Array.isArray(x.highlight.color)) {\n      x.highlight.color = [x.highlight.color];\n    }\n\n    var traceManager = new TraceManager(graphDiv, x.highlight);\n\n    // Gather all *unique* sets.\n    var allSets = [];\n    for (var curveIdx = 0; curveIdx < x.data.length; curveIdx++) {\n      var newSet = x.data[curveIdx].set;\n      if (newSet) {\n        if (allSets.indexOf(newSet) === -1) {\n          allSets.push(newSet);\n        }\n      }\n    }\n\n    // register event listeners for all sets\n    for (var i = 0; i < allSets.length; i++) {\n      \n      var set = allSets[i];\n      var selection = new crosstalk.SelectionHandle(set);\n      var filter = new crosstalk.FilterHandle(set);\n      \n      var filterChange = function(e) {\n        removeBrush(el);\n        traceManager.updateFilter(set, e.value);\n      };\n      filter.on(\"change\", filterChange);\n      \n      \n      var selectionChange = function(e) {\n        \n        // Workaround for 'plotly_selected' now firing previously selected\n        // points (in addition to new ones) when holding shift key. In our case,\n        // we just want the new keys \n        if (x.highlight.on === \"plotly_selected\" && x.highlight.persistentShift) {\n          // https://stackoverflow.com/questions/1187518/how-to-get-the-difference-between-two-arrays-in-javascript\n          Array.prototype.diff = function(a) {\n              return this.filter(function(i) {return a.indexOf(i) < 0;});\n          };\n          e.value = e.value.diff(e.oldValue);\n        }\n        \n        // array of \"event objects\" tracking the selection history\n        // this is used to avoid adding redundant selections\n        var selectionHistory = crosstalk.var(\"plotlySelectionHistory\").get() || [];\n        \n        // Construct an event object \"defining\" the current event. \n        var event = {\n          receiverID: traceManager.gd.id,\n          plotlySelectionColour: crosstalk.group(set).var(\"plotlySelectionColour\").get()\n        };\n        event[set] = e.value;\n        // TODO: is there a smarter way to check object equality?\n        if (selectionHistory.length > 0) {\n          var ev = JSON.stringify(event);\n          for (var i = 0; i < selectionHistory.length; i++) {\n            var sel = JSON.stringify(selectionHistory[i]);\n            if (sel == ev) {\n              return;\n            }\n          }\n        }\n        \n        // accumulate history for persistent selection\n        if (!x.highlight.persistent) {\n          selectionHistory = [event];\n        } else {\n          selectionHistory.push(event);\n        }\n        crosstalk.var(\"plotlySelectionHistory\").set(selectionHistory);\n        \n        // do the actual updating of traces, frames, and the selectize widget\n        traceManager.updateSelection(set, e.value);\n        // https://github.com/selectize/selectize.js/blob/master/docs/api.md#methods_items\n        if (x.selectize) {\n          if (!x.highlight.persistent || e.value === null) {\n            selectize.clear(true);\n          }\n          selectize.addItems(e.value, true);\n          selectize.close();\n        }\n      }\n      selection.on(\"change\", selectionChange);\n      \n      // Set a crosstalk variable selection value, triggering an update\n      var turnOn = function(e) {\n        if (e) {\n          var selectedKeys = pointsToKeys(e.points);\n          // Keys are group names, values are array of selected keys from group.\n          for (var set in selectedKeys) {\n            if (selectedKeys.hasOwnProperty(set)) {\n              selection.set(selectedKeys[set].value, {sender: el});\n            }\n          }\n        }\n      };\n      if (x.highlight.debounce > 0) {\n        turnOn = debounce(turnOn, x.highlight.debounce);\n      }\n      graphDiv.on(x.highlight.on, turnOn);\n      \n      graphDiv.on(x.highlight.off, function turnOff(e) {\n        // remove any visual clues\n        removeBrush(el);\n        // remove any selection history\n        crosstalk.var(\"plotlySelectionHistory\").set(null);\n        // trigger the actual removal of selection traces\n        selection.set(null, {sender: el});\n      });\n          \n      // register a callback for selectize so that there is bi-directional\n      // communication between the widget and direct manipulation events\n      if (x.selectize) {\n        var selectizeID = Object.keys(x.selectize)[i];\n        var items = x.selectize[selectizeID].items;\n        var first = [{value: \"\", label: \"(All)\"}];\n        var opts = {\n          options: first.concat(items),\n          searchField: \"label\",\n          valueField: \"value\",\n          labelField: \"label\",\n          maxItems: 50\n        };\n        var select = $(\"#\" + selectizeID).find(\"select\")[0];\n        var selectize = $(select).selectize(opts)[0].selectize;\n        // NOTE: this callback is triggered when *directly* altering \n        // dropdown items\n        selectize.on(\"change\", function() {\n          var currentItems = traceManager.groupSelections[set] || [];\n          if (!x.highlight.persistent) {\n            removeBrush(el);\n            for (var i = 0; i < currentItems.length; i++) {\n              selectize.removeItem(currentItems[i], true);\n            }\n          }\n          var newItems = selectize.items.filter(function(idx) { \n            return currentItems.indexOf(idx) < 0;\n          });\n          if (newItems.length > 0) {\n            traceManager.updateSelection(set, newItems);\n          } else {\n            // Item has been removed...\n            // TODO: this logic won't work for dynamically changing palette \n            traceManager.updateSelection(set, null);\n            traceManager.updateSelection(set, selectize.items);\n          }\n        });\n      }\n    } // end of selectionChange\n  } // end of renderValue\n}\n\n/**\n * @param graphDiv The Plotly graph div\n * @param highlight An object with options for updating selection(s)\n */\nfunction TraceManager(graphDiv, highlight) {\n  // The Plotly graph div\n  this.gd = graphDiv;\n\n  // Preserve the original data.\n  // TODO: try using Lib.extendFlat() as done in  \n  // https://github.com/plotly/plotly.js/pull/1136 \n  this.origData = JSON.parse(JSON.stringify(graphDiv.data));\n  \n  // avoid doing this over and over\n  this.origOpacity = [];\n  for (var i = 0; i < this.origData.length; i++) {\n    this.origOpacity[i] = this.origData[i].opacity === 0 ? 0 : (this.origData[i].opacity || 1);\n  }\n\n  // key: group name, value: null or array of keys representing the\n  // most recently received selection for that group.\n  this.groupSelections = {};\n  \n  // selection parameters (e.g., transient versus persistent selection)\n  this.highlight = highlight;\n}\n\nTraceManager.prototype.close = function() {\n  // TODO: Unhook all event handlers\n};\n\nTraceManager.prototype.updateFilter = function(group, keys) {\n\n  if (typeof(keys) === \"undefined\" || keys === null) {\n    \n    this.gd.data = JSON.parse(JSON.stringify(this.origData));\n    \n  } else {\n  \n    var traces = [];\n    for (var i = 0; i < this.origData.length; i++) {\n      var trace = this.origData[i];\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        if (!trace._isSimpleKey) {\n          // subsetArrayAttrs doesn't mutate trace (it makes a modified clone)\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        traces.push(trace);\n      }\n    }\n  }\n  \n  this.gd.data = traces;\n  Plotly.redraw(this.gd);\n  \n  // NOTE: we purposely do _not_ restore selection(s), since on filter,\n  // axis likely will update, changing the pixel -> data mapping, leading \n  // to a likely mismatch in the brush outline and highlighted marks\n  \n};\n\nTraceManager.prototype.updateSelection = function(group, keys) {\n  \n  if (keys !== null && !Array.isArray(keys)) {\n    throw new Error(\"Invalid keys argument; null or array expected\");\n  }\n  \n  // if selection has been cleared, or if this is transient\n  // selection, delete the \"selection traces\"\n  var nNewTraces = this.gd.data.length - this.origData.length;\n  if (keys === null || !this.highlight.persistent && nNewTraces > 0) {\n    var tracesToRemove = [];\n    for (var i = 0; i < this.gd.data.length; i++) {\n      if (this.gd.data[i]._isCrosstalkTrace) tracesToRemove.push(i);\n    }\n    Plotly.deleteTraces(this.gd, tracesToRemove);\n    this.groupSelections[group] = keys;\n  } else {\n    // add to the groupSelection, rather than overwriting it\n    // TODO: can this be removed?\n    this.groupSelections[group] = this.groupSelections[group] || [];\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i];\n      if (this.groupSelections[group].indexOf(k) < 0) {\n        this.groupSelections[group].push(k);\n      }\n    }\n  }\n  \n  if (keys === null) {\n    \n    Plotly.restyle(this.gd, {\"opacity\": this.origOpacity});\n    \n  } else if (keys.length >= 1) {\n    \n    // placeholder for new \"selection traces\"\n    var traces = [];\n    // this variable is set in R/highlight.R\n    var selectionColour = crosstalk.group(group).var(\"plotlySelectionColour\").get() || \n      this.highlight.color[0];\n\n    for (var i = 0; i < this.origData.length; i++) {\n      // TODO: try using Lib.extendFlat() as done in  \n      // https://github.com/plotly/plotly.js/pull/1136 \n      var trace = JSON.parse(JSON.stringify(this.gd.data[i]));\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      // Get sorted array of matching indices in trace.key\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        // If this is a \"simple\" key, that means select the entire trace\n        if (!trace._isSimpleKey) {\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        // reach into the full trace object so we can properly reflect the \n        // selection attributes in every view\n        var d = this.gd._fullData[i];\n        \n        /* \n        / Recursively inherit selection attributes from various sources, \n        / in order of preference:\n        /  (1) official plotly.js selected attribute\n        /  (2) highlight(selected = attrs_selected(...))\n        */\n        // TODO: it would be neat to have a dropdown to dynamically specify these!\n        $.extend(true, trace, this.highlight.selected);\n        \n        // if it is defined, override color with the \"dynamic brush color\"\"\n        if (d.marker) {\n          trace.marker = trace.marker || {};\n          trace.marker.color =  selectionColour || trace.marker.color || d.marker.color;\n        }\n        if (d.line) {\n          trace.line = trace.line || {};\n          trace.line.color =  selectionColour || trace.line.color || d.line.color;\n        }\n        if (d.textfont) {\n          trace.textfont = trace.textfont || {};\n          trace.textfont.color =  selectionColour || trace.textfont.color || d.textfont.color;\n        }\n        if (d.fillcolor) {\n          // TODO: should selectionColour inherit alpha from the existing fillcolor?\n          trace.fillcolor = selectionColour || trace.fillcolor || d.fillcolor;\n        }\n        // attach a sensible name/legendgroup\n        trace.name = trace.name || keys.join(\"<br />\");\n        trace.legendgroup = trace.legendgroup || keys.join(\"<br />\");\n        \n        // keep track of mapping between this new trace and the trace it targets\n        // (necessary for updating frames to reflect the selection traces)\n        trace._originalIndex = i;\n        trace._newIndex = this.gd._fullData.length + traces.length;\n        trace._isCrosstalkTrace = true;\n        traces.push(trace);\n      }\n    }\n    \n    if (traces.length > 0) {\n      \n      Plotly.addTraces(this.gd, traces).then(function(gd) {\n        // incrementally add selection traces to frames\n        // (this is heavily inspired by Plotly.Plots.modifyFrames() \n        // in src/plots/plots.js)\n        var _hash = gd._transitionData._frameHash;\n        var _frames = gd._transitionData._frames || [];\n        \n        for (var i = 0; i < _frames.length; i++) {\n          \n          // add to _frames[i].traces *if* this frame references selected trace(s)\n          var newIndices = [];\n          for (var j = 0; j < traces.length; j++) {\n            var tr = traces[j];\n            if (_frames[i].traces.indexOf(tr._originalIndex) > -1) {\n              newIndices.push(tr._newIndex);\n              _frames[i].traces.push(tr._newIndex);\n            }\n          }\n          \n          // nothing to do...\n          if (newIndices.length === 0) {\n            continue;\n          }\n          \n          var ctr = 0;\n          var nFrameTraces = _frames[i].data.length;\n          \n          for (var j = 0; j < nFrameTraces; j++) {\n            var frameTrace = _frames[i].data[j];\n            if (!frameTrace.key || frameTrace.set !== group) {\n              continue;\n            }\n            \n            var matchFunc = getMatchFunc(frameTrace);\n            var matches = matchFunc(frameTrace.key, keys);\n            \n            if (matches.length > 0) {\n              if (!trace._isSimpleKey) {\n                frameTrace = subsetArrayAttrs(frameTrace, matches);\n              }\n              var d = gd._fullData[newIndices[ctr]];\n              if (d.marker) {\n                frameTrace.marker = d.marker;\n              }\n              if (d.line) {\n                frameTrace.line = d.line;\n              }\n              if (d.textfont) {\n                frameTrace.textfont = d.textfont;\n              }\n              ctr = ctr + 1;\n              _frames[i].data.push(frameTrace);\n            }\n          }\n          \n          // update gd._transitionData._frameHash\n          _hash[_frames[i].name] = _frames[i];\n        }\n      \n      });\n      \n      // dim traces that have a set matching the set of selection sets\n      var tracesToDim = [],\n          opacities = [],\n          sets = Object.keys(this.groupSelections),\n          n = this.origData.length;\n          \n      for (var i = 0; i < n; i++) {\n        var opacity = this.origOpacity[i] || 1;\n        // have we already dimmed this trace? Or is this even worth doing?\n        if (opacity !== this.gd._fullData[i].opacity || this.highlight.opacityDim === 1) {\n          continue;\n        }\n        // is this set an element of the set of selection sets?\n        var matches = findMatches(sets, [this.gd.data[i].set]);\n        if (matches.length) {\n          tracesToDim.push(i);\n          opacities.push(opacity * this.highlight.opacityDim);\n        }\n      }\n      \n      if (tracesToDim.length > 0) {\n        Plotly.restyle(this.gd, {\"opacity\": opacities}, tracesToDim);\n        // turn off the selected/unselected API\n        Plotly.restyle(this.gd, {\"selectedpoints\": null});\n      }\n      \n    }\n    \n  }\n};\n\n/* \nNote: in all of these match functions, we assume needleSet (i.e. the selected keys)\nis a 1D (or flat) array. The real difference is the meaning of haystack.\nfindMatches() does the usual thing you'd expect for \nlinked brushing on a scatterplot matrix. findSimpleMatches() returns a match iff \nhaystack is a subset of the needleSet. findNestedMatches() returns \n*/\n\nfunction getMatchFunc(trace) {\n  return (trace._isNestedKey) ? findNestedMatches : \n    (trace._isSimpleKey) ? findSimpleMatches : findMatches;\n}\n\n// find matches for \"flat\" keys\nfunction findMatches(haystack, needleSet) {\n  var matches = [];\n  haystack.forEach(function(obj, i) {\n    if (obj === null || needleSet.indexOf(obj) >= 0) {\n      matches.push(i);\n    }\n  });\n  return matches;\n}\n\n// find matches for \"simple\" keys\nfunction findSimpleMatches(haystack, needleSet) {\n  var match = haystack.every(function(val) {\n    return val === null || needleSet.indexOf(val) >= 0;\n  });\n  // yes, this doesn't make much sense other than conforming \n  // to the output type of the other match functions\n  return (match) ? [0] : []\n}\n\n// find matches for a \"nested\" haystack (2D arrays)\nfunction findNestedMatches(haystack, needleSet) {\n  var matches = [];\n  for (var i = 0; i < haystack.length; i++) {\n    var hay = haystack[i];\n    var match = hay.every(function(val) { \n      return val === null || needleSet.indexOf(val) >= 0; \n    });\n    if (match) {\n      matches.push(i);\n    }\n  }\n  return matches;\n}\n\nfunction isPlainObject(obj) {\n  return (\n    Object.prototype.toString.call(obj) === '[object Object]' &&\n    Object.getPrototypeOf(obj) === Object.prototype\n  );\n}\n\nfunction subsetArrayAttrs(obj, indices) {\n  var newObj = {};\n  Object.keys(obj).forEach(function(k) {\n    var val = obj[k];\n\n    if (k.charAt(0) === \"_\") {\n      newObj[k] = val;\n    } else if (k === \"transforms\" && Array.isArray(val)) {\n      newObj[k] = val.map(function(transform) {\n        return subsetArrayAttrs(transform, indices);\n      });\n    } else if (k === \"colorscale\" && Array.isArray(val)) {\n      newObj[k] = val;\n    } else if (isPlainObject(val)) {\n      newObj[k] = subsetArrayAttrs(val, indices);\n    } else if (Array.isArray(val)) {\n      newObj[k] = subsetArray(val, indices);\n    } else {\n      newObj[k] = val;\n    }\n  });\n  return newObj;\n}\n\nfunction subsetArray(arr, indices) {\n  var result = [];\n  for (var i = 0; i < indices.length; i++) {\n    result.push(arr[indices[i]]);\n  }\n  return result;\n}\n\n// Convenience function for removing plotly's brush \nfunction removeBrush(el) {\n  var outlines = el.querySelectorAll(\".select-outline\");\n  for (var i = 0; i < outlines.length; i++) {\n    outlines[i].remove();\n  }\n}\n\n\n// https://davidwalsh.name/javascript-debounce-function\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\nfunction debounce(func, wait, immediate) {\n\tvar timeout;\n\treturn function() {\n\t\tvar context = this, args = arguments;\n\t\tvar later = function() {\n\t\t\ttimeout = null;\n\t\t\tif (!immediate) func.apply(context, args);\n\t\t};\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t\tif (callNow) func.apply(context, args);\n\t};\n};\n\nmodule.exports = widgetDefinition"]}