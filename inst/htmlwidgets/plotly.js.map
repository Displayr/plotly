{"version":3,"sources":["node_modules/browser-pack/_prelude.js","theSrc/scripts/plotly.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","TraceManager","graphDiv","highlight","this","gd","origData","JSON","parse","stringify","data","origOpacity","opacity","groupSelections","getMatchFunc","trace","_isNestedKey","findNestedMatches","_isSimpleKey","findSimpleMatches","findMatches","haystack","needleSet","matches","forEach","obj","indexOf","push","every","val","subsetArrayAttrs","indices","newObj","Object","keys","k","charAt","Array","isArray","map","transform","prototype","toString","getPrototypeOf","arr","result","subsetArray","removeBrush","el","outlines","querySelectorAll","remove","HTMLWidgets","widget","name","type","initialize","width","height","resize","instance","autosize","Plotly","relayout","renderValue","x","lay","layout","crosstalk","var","set","window","PLOTLYENV","BASE_URL","base_url","persistent","onmousemove","event","shiftKey","persistentShift","document","getElementById","id","addPostRenderHandler","modebars","style","zIndex","selectize","dynamic","plotly","pickerDiv","flex","createElement","class","pickerInput","placeholder","pickerLabel","for","innerHTML","appendChild","ids","container","label","group","selectDiv","select","multiple","parentElement","insertBefore","picker","$","colors","color","opts","value","showColour","palette","allowedCols","join","colourpicker","changeDelay","grps","ctGroups","on","eventDataWithKey","eventData","undefined","hasOwnProperty","points","pt","curveNumber","pointNumber","y","z","customdata","attrsToAttach","key","attr","pointNumbers","idx","purge","plot","then","shinyMode","Shiny","addCustomMessageHandler","msg","method","args","concat","apply","react","mapboxIDs","_fullLayout","_subplots","mapbox","_fitBounds","_subplot","fitBounds","bounds","options","eventClearMap","eventDataFunctionMap","legendEventData","d","legendgroup","legendgrps","traces","setInputValue","plotly_deselect","plotly_unhover","plotly_doubleclick","evt","input","source","priority","plotly_click","plotly_sunburstclick","plotly_hover","plotly_selected","plotly_selecting","plotly_brushed","range","lassoPoints","plotly_brushing","plotly_legendclick","plotly_legenddoubleclick","plotly_clickannotation","fullAnnotation","shinyEvents","eventDataPreProcessor","traceManager","allSets","curveIdx","newSet","selection","SelectionHandle","FilterHandle","updateFilter","diff","filter","oldValue","selectionHistory","get","receiverID","plotlySelectionColour","ev","updateSelection","clear","addItems","close","selectizeID","turnOn","selectedKeys","keysBySet","keyFlat","ptNum","pointsToKeys","sender","debounce","func","wait","immediate","timeout","context","arguments","callNow","clearTimeout","setTimeout","off","items","searchField","valueField","labelField","maxItems","find","currentItems","removeItem","newItems","matchFunc","redraw","nNewTraces","tracesToRemove","_isCrosstalkTrace","deleteTraces","restyle","selectionColour","_fullData","extend","selected","marker","line","textfont","fillcolor","_originalIndex","_newIndex","addTraces","_hash","_transitionData","_frameHash","_frames","newIndices","j","tr","ctr","nFrameTraces","frameTrace","tracesToDim","opacities","sets","opacityDim","selectedpoints"],"mappings":"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","file":"plotly.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","HTMLWidgets.widget({\n  name: \"plotly\",\n  type: \"output\",\n\n  initialize: function(el, width, height) {\n    return {};\n  },\n\n  resize: function(el, width, height, instance) {\n    if (instance.autosize) {\n      var width = instance.width || width;\n      var height = instance.height || height;\n      Plotly.relayout(el, {width: width, height: height});\n    }\n  },  \n  \n  renderValue: function(el, x, instance) {\n    \n    // Plotly.relayout() mutates the plot input object, so make sure to \n    // keep a reference to the user-supplied width/height *before*\n    // we call Plotly.plot();\n    var lay = x.layout || {};\n    instance.width = lay.width;\n    instance.height = lay.height;\n    instance.autosize = lay.autosize || true;\n    \n    /* \n    / 'inform the world' about highlighting options this is so other\n    / crosstalk libraries have a chance to respond to special settings \n    / such as persistent selection. \n    / AFAIK, leaflet is the only library with such intergration\n    / https://github.com/rstudio/leaflet/pull/346/files#diff-ad0c2d51ce5fdf8c90c7395b102f4265R154\n    */\n    var ctConfig = crosstalk.var('plotlyCrosstalkOpts').set(x.highlight);\n      \n    if (typeof(window) !== \"undefined\") {\n      // make sure plots don't get created outside the network (for on-prem)\n      window.PLOTLYENV = window.PLOTLYENV || {};\n      window.PLOTLYENV.BASE_URL = x.base_url;\n      \n      // Enable persistent selection when shift key is down\n      // https://stackoverflow.com/questions/1828613/check-if-a-key-is-down\n      var persistOnShift = function(e) {\n        if (!e) window.event;\n        if (e.shiftKey) { \n          x.highlight.persistent = true; \n          x.highlight.persistentShift = true;\n        } else {\n          x.highlight.persistent = false; \n          x.highlight.persistentShift = false;\n        }\n      };\n      \n      // Only relevant if we haven't forced persistent mode at command line\n      if (!x.highlight.persistent) {\n        window.onmousemove = persistOnShift;\n      }\n    }\n\n    var graphDiv = document.getElementById(el.id);\n    \n    // TODO: move the control panel injection strategy inside here...\n    HTMLWidgets.addPostRenderHandler(function() {\n      \n      // lower the z-index of the modebar to prevent it from highjacking hover\n      // (TODO: do this via CSS?)\n      // https://github.com/ropensci/plotly/issues/956\n      // https://www.w3schools.com/jsref/prop_style_zindex.asp\n      var modebars = document.querySelectorAll(\".js-plotly-plot .plotly .modebar\");\n      for (var i = 0; i < modebars.length; i++) {\n        modebars[i].style.zIndex = 1;\n      }\n    });\n      \n      // inject a \"control panel\" holding selectize/dynamic color widget(s)\n    if ((x.selectize || x.highlight.dynamic) && !instance.plotly) {\n      var flex = document.createElement(\"div\");\n      flex.class = \"plotly-crosstalk-control-panel\";\n      flex.style = \"display: flex; flex-wrap: wrap\";\n      \n      // inject the colourpicker HTML container into the flexbox\n      if (x.highlight.dynamic) {\n        var pickerDiv = document.createElement(\"div\");\n        \n        var pickerInput = document.createElement(\"input\");\n        pickerInput.id = el.id + \"-colourpicker\";\n        pickerInput.placeholder = \"asdasd\";\n        \n        var pickerLabel = document.createElement(\"label\");\n        pickerLabel.for = pickerInput.id;\n        pickerLabel.innerHTML = \"Brush color&nbsp;&nbsp;\";\n        \n        pickerDiv.appendChild(pickerLabel);\n        pickerDiv.appendChild(pickerInput);\n        flex.appendChild(pickerDiv);\n      }\n      \n      // inject selectize HTML containers (one for every crosstalk group)\n      if (x.selectize) {\n        var ids = Object.keys(x.selectize);\n        \n        for (var i = 0; i < ids.length; i++) {\n          var container = document.createElement(\"div\");\n          container.id = ids[i];\n          container.style = \"width: 80%; height: 10%\";\n          container.class = \"form-group crosstalk-input-plotly-highlight\";\n          \n          var label = document.createElement(\"label\");\n          label.for = ids[i];\n          label.innerHTML = x.selectize[ids[i]].group;\n          label.class = \"control-label\";\n          \n          var selectDiv = document.createElement(\"div\");\n          var select = document.createElement(\"select\");\n          select.multiple = true;\n          \n          selectDiv.appendChild(select);\n          container.appendChild(label);\n          container.appendChild(selectDiv);\n          flex.appendChild(container);\n        }\n      }\n      \n      // finally, insert the flexbox inside the htmlwidget container,\n      // but before the plotly graph div\n      graphDiv.parentElement.insertBefore(flex, graphDiv);\n      \n      if (x.highlight.dynamic) {\n        var picker = $(\"#\" + pickerInput.id);\n        var colors = x.highlight.color || [];\n        // TODO: let users specify options?\n        var opts = {\n          value: colors[0],\n          showColour: \"both\",\n          palette: \"limited\",\n          allowedCols: colors.join(\" \"),\n          width: \"20%\",\n          height: \"10%\"\n        };\n        picker.colourpicker({changeDelay: 0});\n        picker.colourpicker(\"settings\", opts);\n        picker.colourpicker(\"value\", opts.value);\n        // inform crosstalk about a change in the current selection colour\n        var grps = x.highlight.ctGroups || [];\n        for (var i = 0; i < grps.length; i++) {\n          crosstalk.group(grps[i]).var('plotlySelectionColour')\n            .set(picker.colourpicker('value'));\n        }\n        picker.on(\"change\", function() {\n          for (var i = 0; i < grps.length; i++) {\n            crosstalk.group(grps[i]).var('plotlySelectionColour')\n              .set(picker.colourpicker('value'));\n          }\n        });\n      }\n    }\n    \n    // if no plot exists yet, create one with a particular configuration\n    if (!instance.plotly) {\n      \n      var plot = Plotly.plot(graphDiv, x);\n      instance.plotly = true;\n      \n    } else {\n      \n      // this is essentially equivalent to Plotly.newPlot(), but avoids creating \n      // a new webgl context\n      // https://github.com/plotly/plotly.js/blob/2b24f9def901831e61282076cf3f835598d56f0e/src/plot_api/plot_api.js#L531-L532\n\n      // TODO: restore crosstalk selections?\n      Plotly.purge(graphDiv);\n      // TODO: why is this necessary to get crosstalk working?\n      graphDiv.data = undefined;\n      graphDiv.layout = undefined;\n      var plot = Plotly.plot(graphDiv, x);\n    }\n    \n    // Trigger plotly.js calls defined via `plotlyProxy()`\n    plot.then(function() {\n      if (HTMLWidgets.shinyMode) {\n        Shiny.addCustomMessageHandler(\"plotly-calls\", function(msg) {\n          var gd = document.getElementById(msg.id);\n          if (!gd) {\n            throw new Error(\"Couldn't find plotly graph with id: \" + msg.id);\n          }\n          // This isn't an official plotly.js method, but it's the only current way to \n          // change just the configuration of a plot \n          // https://community.plot.ly/t/update-config-function/9057\n          if (msg.method == \"reconfig\") {\n            Plotly.react(gd, gd.data, gd.layout, msg.args);\n            return;\n          }\n          if (!Plotly[msg.method]) {\n            throw new Error(\"Unknown method \" + msg.method);\n          }\n          var args = [gd].concat(msg.args);\n          Plotly[msg.method].apply(null, args);\n        });\n      }\n      \n      // plotly's mapbox API doesn't currently support setting bounding boxes\n      // https://www.mapbox.com/mapbox-gl-js/example/fitbounds/\n      // so we do this manually...\n      // TODO: make sure this triggers on a redraw and relayout as well as on initial draw\n      var mapboxIDs = graphDiv._fullLayout._subplots.mapbox || [];\n      for (var i = 0; i < mapboxIDs.length; i++) {\n        var id = mapboxIDs[i];\n        var mapOpts = x.layout[id] || {};\n        var args = mapOpts._fitBounds || {};\n        if (!args) {\n          continue;\n        }\n        var mapObj = graphDiv._fullLayout[id]._subplot.map;\n        mapObj.fitBounds(args.bounds, args.options);\n      }\n      \n    });\n    \n    // Attach attributes (e.g., \"key\", \"z\") to plotly event data\n    function eventDataWithKey(eventData) {\n      if (eventData === undefined || !eventData.hasOwnProperty(\"points\")) {\n        return null;\n      }\n      return eventData.points.map(function(pt) {\n        var obj = {\n          curveNumber: pt.curveNumber, \n          pointNumber: pt.pointNumber, \n          x: pt.x,\n          y: pt.y\n        };\n        \n        // If 'z' is reported with the event data, then use it!\n        if (pt.hasOwnProperty(\"z\")) {\n          obj.z = pt.z;\n        }\n        \n        if (pt.hasOwnProperty(\"customdata\")) {\n          obj.customdata = pt.customdata;\n        }\n        \n        /* \n          TL;DR: (I think) we have to select the graph div (again) to attach keys...\n          \n          Why? Remember that crosstalk will dynamically add/delete traces \n          (see traceManager.prototype.updateSelection() below)\n          For this reason, we can't simply grab keys from x.data (like we did previously)\n          Moreover, we can't use _fullData, since that doesn't include \n          unofficial attributes. It's true that click/hover events fire with \n          pt.data, but drag events don't...\n        */\n        var gd = document.getElementById(el.id);\n        var trace = gd.data[pt.curveNumber];\n        \n        if (!trace._isSimpleKey) {\n          var attrsToAttach = [\"key\"];\n        } else {\n          // simple keys fire the whole key\n          obj.key = trace.key;\n          var attrsToAttach = [];\n        }\n        \n        for (var i = 0; i < attrsToAttach.length; i++) {\n          var attr = trace[attrsToAttach[i]];\n          if (Array.isArray(attr)) {\n            if (typeof pt.pointNumber === \"number\") {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber];\n            } else if (Array.isArray(pt.pointNumber)) {\n              obj[attrsToAttach[i]] = attr[pt.pointNumber[0]][pt.pointNumber[1]];\n            } else if (Array.isArray(pt.pointNumbers)) {\n              obj[attrsToAttach[i]] = pt.pointNumbers.map(function(idx) { return attr[idx]; });\n            }\n          }\n        }\n        return obj;\n      });\n    }\n    \n    \n    var legendEventData = function(d) {\n      // if legendgroup is not relevant just return the trace\n      var trace = d.data[d.curveNumber];\n      if (!trace.legendgroup) return trace;\n      \n      // if legendgroup was specified, return all traces that match the group\n      var legendgrps = d.data.map(function(trace){ return trace.legendgroup; });\n      var traces = [];\n      for (i = 0; i < legendgrps.length; i++) {\n        if (legendgrps[i] == trace.legendgroup) {\n          traces.push(d.data[i]);\n        }\n      }\n      \n      return traces;\n    };\n\n    \n    // send user input event data to shiny\n    if (HTMLWidgets.shinyMode && Shiny.setInputValue) {\n      \n      // Some events clear other input values\n      // TODO: always register these?\n      var eventClearMap = {\n        plotly_deselect: [\"plotly_selected\", \"plotly_selecting\", \"plotly_brushed\", \"plotly_brushing\", \"plotly_click\"],\n        plotly_unhover: [\"plotly_hover\"],\n        plotly_doubleclick: [\"plotly_click\"]\n      };\n    \n      Object.keys(eventClearMap).map(function(evt) {\n        graphDiv.on(evt, function() {\n          var inputsToClear = eventClearMap[evt];\n          inputsToClear.map(function(input) {\n            Shiny.setInputValue(input + \"-\" + x.source, null, {priority: \"event\"});\n          });\n        });\n      });\n      \n      var eventDataFunctionMap = {\n        plotly_click: eventDataWithKey,\n        plotly_sunburstclick: eventDataWithKey,\n        plotly_hover: eventDataWithKey,\n        plotly_unhover: eventDataWithKey,\n        // If 'plotly_selected' has already been fired, and you click\n        // on the plot afterwards, this event fires `undefined`?!?\n        // That might be considered a plotly.js bug, but it doesn't make \n        // sense for this input change to occur if `d` is falsy because,\n        // even in the empty selection case, `d` is truthy (an object),\n        // and the 'plotly_deselect' event will reset this input\n        plotly_selected: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_selecting: function(d) { if (d) { return eventDataWithKey(d); } },\n        plotly_brushed: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_brushing: function(d) {\n          if (d) { return d.range ? d.range : d.lassoPoints; }\n        },\n        plotly_legendclick: legendEventData,\n        plotly_legenddoubleclick: legendEventData,\n        plotly_clickannotation: function(d) { return d.fullAnnotation }\n      };\n      \n      var registerShinyValue = function(event) {\n        var eventDataPreProcessor = eventDataFunctionMap[event] || function(d) { return d ? d : el.id };\n        // some events are unique to the R package\n        var plotlyJSevent = (event == \"plotly_brushed\") ? \"plotly_selected\" : (event == \"plotly_brushing\") ? \"plotly_selecting\" : event;\n        // register the event\n        graphDiv.on(plotlyJSevent, function(d) {\n          Shiny.setInputValue(\n            event + \"-\" + x.source,\n            JSON.stringify(eventDataPreProcessor(d)),\n            {priority: \"event\"}\n          );\n        });\n      }\n    \n      var shinyEvents = x.shinyEvents || [];\n      shinyEvents.map(registerShinyValue);\n    }\n    \n    // Given an array of {curveNumber: x, pointNumber: y} objects,\n    // return a hash of {\n    //   set1: {value: [key1, key2, ...], _isSimpleKey: false}, \n    //   set2: {value: [key3, key4, ...], _isSimpleKey: false}\n    // }\n    function pointsToKeys(points) {\n      var keysBySet = {};\n      for (var i = 0; i < points.length; i++) {\n        \n        var trace = graphDiv.data[points[i].curveNumber];\n        if (!trace.key || !trace.set) {\n          continue;\n        }\n        \n        // set defaults for this keySet\n        // note that we don't track the nested property (yet) since we always \n        // emit the union -- http://cpsievert.github.io/talks/20161212b/#21\n        keysBySet[trace.set] = keysBySet[trace.set] || {\n          value: [],\n          _isSimpleKey: trace._isSimpleKey\n        };\n        \n        // Use pointNumber by default, but aggregated traces should emit pointNumbers\n        var ptNum = points[i].pointNumber;\n        var hasPtNum = typeof ptNum === \"number\";\n        var ptNum = hasPtNum ? ptNum : points[i].pointNumbers;\n        \n        // selecting a point of a \"simple\" trace means: select the \n        // entire key attached to this trace, which is useful for,\n        // say clicking on a fitted line to select corresponding observations \n        var key = trace._isSimpleKey ? trace.key : Array.isArray(ptNum) ? ptNum.map(function(idx) { return trace.key[idx]; }) : trace.key[ptNum];\n        // http://stackoverflow.com/questions/10865025/merge-flatten-an-array-of-arrays-in-javascript\n        var keyFlat = trace._isNestedKey ? [].concat.apply([], key) : key;\n        \n        // TODO: better to only add new values?\n        keysBySet[trace.set].value = keysBySet[trace.set].value.concat(keyFlat);\n      }\n      \n      return keysBySet;\n    }\n    \n    \n    x.highlight.color = x.highlight.color || [];\n    // make sure highlight color is an array\n    if (!Array.isArray(x.highlight.color)) {\n      x.highlight.color = [x.highlight.color];\n    }\n\n    var traceManager = new TraceManager(graphDiv, x.highlight);\n\n    // Gather all *unique* sets.\n    var allSets = [];\n    for (var curveIdx = 0; curveIdx < x.data.length; curveIdx++) {\n      var newSet = x.data[curveIdx].set;\n      if (newSet) {\n        if (allSets.indexOf(newSet) === -1) {\n          allSets.push(newSet);\n        }\n      }\n    }\n\n    // register event listeners for all sets\n    for (var i = 0; i < allSets.length; i++) {\n      \n      var set = allSets[i];\n      var selection = new crosstalk.SelectionHandle(set);\n      var filter = new crosstalk.FilterHandle(set);\n      \n      var filterChange = function(e) {\n        removeBrush(el);\n        traceManager.updateFilter(set, e.value);\n      };\n      filter.on(\"change\", filterChange);\n      \n      \n      var selectionChange = function(e) {\n        \n        // Workaround for 'plotly_selected' now firing previously selected\n        // points (in addition to new ones) when holding shift key. In our case,\n        // we just want the new keys \n        if (x.highlight.on === \"plotly_selected\" && x.highlight.persistentShift) {\n          // https://stackoverflow.com/questions/1187518/how-to-get-the-difference-between-two-arrays-in-javascript\n          Array.prototype.diff = function(a) {\n              return this.filter(function(i) {return a.indexOf(i) < 0;});\n          };\n          e.value = e.value.diff(e.oldValue);\n        }\n        \n        // array of \"event objects\" tracking the selection history\n        // this is used to avoid adding redundant selections\n        var selectionHistory = crosstalk.var(\"plotlySelectionHistory\").get() || [];\n        \n        // Construct an event object \"defining\" the current event. \n        var event = {\n          receiverID: traceManager.gd.id,\n          plotlySelectionColour: crosstalk.group(set).var(\"plotlySelectionColour\").get()\n        };\n        event[set] = e.value;\n        // TODO: is there a smarter way to check object equality?\n        if (selectionHistory.length > 0) {\n          var ev = JSON.stringify(event);\n          for (var i = 0; i < selectionHistory.length; i++) {\n            var sel = JSON.stringify(selectionHistory[i]);\n            if (sel == ev) {\n              return;\n            }\n          }\n        }\n        \n        // accumulate history for persistent selection\n        if (!x.highlight.persistent) {\n          selectionHistory = [event];\n        } else {\n          selectionHistory.push(event);\n        }\n        crosstalk.var(\"plotlySelectionHistory\").set(selectionHistory);\n        \n        // do the actual updating of traces, frames, and the selectize widget\n        traceManager.updateSelection(set, e.value);\n        // https://github.com/selectize/selectize.js/blob/master/docs/api.md#methods_items\n        if (x.selectize) {\n          if (!x.highlight.persistent || e.value === null) {\n            selectize.clear(true);\n          }\n          selectize.addItems(e.value, true);\n          selectize.close();\n        }\n      }\n      selection.on(\"change\", selectionChange);\n      \n      // Set a crosstalk variable selection value, triggering an update\n      var turnOn = function(e) {\n        if (e) {\n          var selectedKeys = pointsToKeys(e.points);\n          // Keys are group names, values are array of selected keys from group.\n          for (var set in selectedKeys) {\n            if (selectedKeys.hasOwnProperty(set)) {\n              selection.set(selectedKeys[set].value, {sender: el});\n            }\n          }\n        }\n      };\n      if (x.highlight.debounce > 0) {\n        turnOn = debounce(turnOn, x.highlight.debounce);\n      }\n      graphDiv.on(x.highlight.on, turnOn);\n      \n      graphDiv.on(x.highlight.off, function turnOff(e) {\n        // remove any visual clues\n        removeBrush(el);\n        // remove any selection history\n        crosstalk.var(\"plotlySelectionHistory\").set(null);\n        // trigger the actual removal of selection traces\n        selection.set(null, {sender: el});\n      });\n          \n      // register a callback for selectize so that there is bi-directional\n      // communication between the widget and direct manipulation events\n      if (x.selectize) {\n        var selectizeID = Object.keys(x.selectize)[i];\n        var items = x.selectize[selectizeID].items;\n        var first = [{value: \"\", label: \"(All)\"}];\n        var opts = {\n          options: first.concat(items),\n          searchField: \"label\",\n          valueField: \"value\",\n          labelField: \"label\",\n          maxItems: 50\n        };\n        var select = $(\"#\" + selectizeID).find(\"select\")[0];\n        var selectize = $(select).selectize(opts)[0].selectize;\n        // NOTE: this callback is triggered when *directly* altering \n        // dropdown items\n        selectize.on(\"change\", function() {\n          var currentItems = traceManager.groupSelections[set] || [];\n          if (!x.highlight.persistent) {\n            removeBrush(el);\n            for (var i = 0; i < currentItems.length; i++) {\n              selectize.removeItem(currentItems[i], true);\n            }\n          }\n          var newItems = selectize.items.filter(function(idx) { \n            return currentItems.indexOf(idx) < 0;\n          });\n          if (newItems.length > 0) {\n            traceManager.updateSelection(set, newItems);\n          } else {\n            // Item has been removed...\n            // TODO: this logic won't work for dynamically changing palette \n            traceManager.updateSelection(set, null);\n            traceManager.updateSelection(set, selectize.items);\n          }\n        });\n      }\n    } // end of selectionChange\n    \n  } // end of renderValue\n}); // end of widget definition\n\n/**\n * @param graphDiv The Plotly graph div\n * @param highlight An object with options for updating selection(s)\n */\nfunction TraceManager(graphDiv, highlight) {\n  // The Plotly graph div\n  this.gd = graphDiv;\n\n  // Preserve the original data.\n  // TODO: try using Lib.extendFlat() as done in  \n  // https://github.com/plotly/plotly.js/pull/1136 \n  this.origData = JSON.parse(JSON.stringify(graphDiv.data));\n  \n  // avoid doing this over and over\n  this.origOpacity = [];\n  for (var i = 0; i < this.origData.length; i++) {\n    this.origOpacity[i] = this.origData[i].opacity === 0 ? 0 : (this.origData[i].opacity || 1);\n  }\n\n  // key: group name, value: null or array of keys representing the\n  // most recently received selection for that group.\n  this.groupSelections = {};\n  \n  // selection parameters (e.g., transient versus persistent selection)\n  this.highlight = highlight;\n}\n\nTraceManager.prototype.close = function() {\n  // TODO: Unhook all event handlers\n};\n\nTraceManager.prototype.updateFilter = function(group, keys) {\n\n  if (typeof(keys) === \"undefined\" || keys === null) {\n    \n    this.gd.data = JSON.parse(JSON.stringify(this.origData));\n    \n  } else {\n  \n    var traces = [];\n    for (var i = 0; i < this.origData.length; i++) {\n      var trace = this.origData[i];\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        if (!trace._isSimpleKey) {\n          // subsetArrayAttrs doesn't mutate trace (it makes a modified clone)\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        traces.push(trace);\n      }\n    }\n  }\n  \n  this.gd.data = traces;\n  Plotly.redraw(this.gd);\n  \n  // NOTE: we purposely do _not_ restore selection(s), since on filter,\n  // axis likely will update, changing the pixel -> data mapping, leading \n  // to a likely mismatch in the brush outline and highlighted marks\n  \n};\n\nTraceManager.prototype.updateSelection = function(group, keys) {\n  \n  if (keys !== null && !Array.isArray(keys)) {\n    throw new Error(\"Invalid keys argument; null or array expected\");\n  }\n  \n  // if selection has been cleared, or if this is transient\n  // selection, delete the \"selection traces\"\n  var nNewTraces = this.gd.data.length - this.origData.length;\n  if (keys === null || !this.highlight.persistent && nNewTraces > 0) {\n    var tracesToRemove = [];\n    for (var i = 0; i < this.gd.data.length; i++) {\n      if (this.gd.data[i]._isCrosstalkTrace) tracesToRemove.push(i);\n    }\n    Plotly.deleteTraces(this.gd, tracesToRemove);\n    this.groupSelections[group] = keys;\n  } else {\n    // add to the groupSelection, rather than overwriting it\n    // TODO: can this be removed?\n    this.groupSelections[group] = this.groupSelections[group] || [];\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i];\n      if (this.groupSelections[group].indexOf(k) < 0) {\n        this.groupSelections[group].push(k);\n      }\n    }\n  }\n  \n  if (keys === null) {\n    \n    Plotly.restyle(this.gd, {\"opacity\": this.origOpacity});\n    \n  } else if (keys.length >= 1) {\n    \n    // placeholder for new \"selection traces\"\n    var traces = [];\n    // this variable is set in R/highlight.R\n    var selectionColour = crosstalk.group(group).var(\"plotlySelectionColour\").get() || \n      this.highlight.color[0];\n\n    for (var i = 0; i < this.origData.length; i++) {\n      // TODO: try using Lib.extendFlat() as done in  \n      // https://github.com/plotly/plotly.js/pull/1136 \n      var trace = JSON.parse(JSON.stringify(this.gd.data[i]));\n      if (!trace.key || trace.set !== group) {\n        continue;\n      }\n      // Get sorted array of matching indices in trace.key\n      var matchFunc = getMatchFunc(trace);\n      var matches = matchFunc(trace.key, keys);\n      \n      if (matches.length > 0) {\n        // If this is a \"simple\" key, that means select the entire trace\n        if (!trace._isSimpleKey) {\n          trace = subsetArrayAttrs(trace, matches);\n        }\n        // reach into the full trace object so we can properly reflect the \n        // selection attributes in every view\n        var d = this.gd._fullData[i];\n        \n        /* \n        / Recursively inherit selection attributes from various sources, \n        / in order of preference:\n        /  (1) official plotly.js selected attribute\n        /  (2) highlight(selected = attrs_selected(...))\n        */\n        // TODO: it would be neat to have a dropdown to dynamically specify these!\n        $.extend(true, trace, this.highlight.selected);\n        \n        // if it is defined, override color with the \"dynamic brush color\"\"\n        if (d.marker) {\n          trace.marker = trace.marker || {};\n          trace.marker.color =  selectionColour || trace.marker.color || d.marker.color;\n        }\n        if (d.line) {\n          trace.line = trace.line || {};\n          trace.line.color =  selectionColour || trace.line.color || d.line.color;\n        }\n        if (d.textfont) {\n          trace.textfont = trace.textfont || {};\n          trace.textfont.color =  selectionColour || trace.textfont.color || d.textfont.color;\n        }\n        if (d.fillcolor) {\n          // TODO: should selectionColour inherit alpha from the existing fillcolor?\n          trace.fillcolor = selectionColour || trace.fillcolor || d.fillcolor;\n        }\n        // attach a sensible name/legendgroup\n        trace.name = trace.name || keys.join(\"<br />\");\n        trace.legendgroup = trace.legendgroup || keys.join(\"<br />\");\n        \n        // keep track of mapping between this new trace and the trace it targets\n        // (necessary for updating frames to reflect the selection traces)\n        trace._originalIndex = i;\n        trace._newIndex = this.gd._fullData.length + traces.length;\n        trace._isCrosstalkTrace = true;\n        traces.push(trace);\n      }\n    }\n    \n    if (traces.length > 0) {\n      \n      Plotly.addTraces(this.gd, traces).then(function(gd) {\n        // incrementally add selection traces to frames\n        // (this is heavily inspired by Plotly.Plots.modifyFrames() \n        // in src/plots/plots.js)\n        var _hash = gd._transitionData._frameHash;\n        var _frames = gd._transitionData._frames || [];\n        \n        for (var i = 0; i < _frames.length; i++) {\n          \n          // add to _frames[i].traces *if* this frame references selected trace(s)\n          var newIndices = [];\n          for (var j = 0; j < traces.length; j++) {\n            var tr = traces[j];\n            if (_frames[i].traces.indexOf(tr._originalIndex) > -1) {\n              newIndices.push(tr._newIndex);\n              _frames[i].traces.push(tr._newIndex);\n            }\n          }\n          \n          // nothing to do...\n          if (newIndices.length === 0) {\n            continue;\n          }\n          \n          var ctr = 0;\n          var nFrameTraces = _frames[i].data.length;\n          \n          for (var j = 0; j < nFrameTraces; j++) {\n            var frameTrace = _frames[i].data[j];\n            if (!frameTrace.key || frameTrace.set !== group) {\n              continue;\n            }\n            \n            var matchFunc = getMatchFunc(frameTrace);\n            var matches = matchFunc(frameTrace.key, keys);\n            \n            if (matches.length > 0) {\n              if (!trace._isSimpleKey) {\n                frameTrace = subsetArrayAttrs(frameTrace, matches);\n              }\n              var d = gd._fullData[newIndices[ctr]];\n              if (d.marker) {\n                frameTrace.marker = d.marker;\n              }\n              if (d.line) {\n                frameTrace.line = d.line;\n              }\n              if (d.textfont) {\n                frameTrace.textfont = d.textfont;\n              }\n              ctr = ctr + 1;\n              _frames[i].data.push(frameTrace);\n            }\n          }\n          \n          // update gd._transitionData._frameHash\n          _hash[_frames[i].name] = _frames[i];\n        }\n      \n      });\n      \n      // dim traces that have a set matching the set of selection sets\n      var tracesToDim = [],\n          opacities = [],\n          sets = Object.keys(this.groupSelections),\n          n = this.origData.length;\n          \n      for (var i = 0; i < n; i++) {\n        var opacity = this.origOpacity[i] || 1;\n        // have we already dimmed this trace? Or is this even worth doing?\n        if (opacity !== this.gd._fullData[i].opacity || this.highlight.opacityDim === 1) {\n          continue;\n        }\n        // is this set an element of the set of selection sets?\n        var matches = findMatches(sets, [this.gd.data[i].set]);\n        if (matches.length) {\n          tracesToDim.push(i);\n          opacities.push(opacity * this.highlight.opacityDim);\n        }\n      }\n      \n      if (tracesToDim.length > 0) {\n        Plotly.restyle(this.gd, {\"opacity\": opacities}, tracesToDim);\n        // turn off the selected/unselected API\n        Plotly.restyle(this.gd, {\"selectedpoints\": null});\n      }\n      \n    }\n    \n  }\n};\n\n/* \nNote: in all of these match functions, we assume needleSet (i.e. the selected keys)\nis a 1D (or flat) array. The real difference is the meaning of haystack.\nfindMatches() does the usual thing you'd expect for \nlinked brushing on a scatterplot matrix. findSimpleMatches() returns a match iff \nhaystack is a subset of the needleSet. findNestedMatches() returns \n*/\n\nfunction getMatchFunc(trace) {\n  return (trace._isNestedKey) ? findNestedMatches : \n    (trace._isSimpleKey) ? findSimpleMatches : findMatches;\n}\n\n// find matches for \"flat\" keys\nfunction findMatches(haystack, needleSet) {\n  var matches = [];\n  haystack.forEach(function(obj, i) {\n    if (obj === null || needleSet.indexOf(obj) >= 0) {\n      matches.push(i);\n    }\n  });\n  return matches;\n}\n\n// find matches for \"simple\" keys\nfunction findSimpleMatches(haystack, needleSet) {\n  var match = haystack.every(function(val) {\n    return val === null || needleSet.indexOf(val) >= 0;\n  });\n  // yes, this doesn't make much sense other than conforming \n  // to the output type of the other match functions\n  return (match) ? [0] : []\n}\n\n// find matches for a \"nested\" haystack (2D arrays)\nfunction findNestedMatches(haystack, needleSet) {\n  var matches = [];\n  for (var i = 0; i < haystack.length; i++) {\n    var hay = haystack[i];\n    var match = hay.every(function(val) { \n      return val === null || needleSet.indexOf(val) >= 0; \n    });\n    if (match) {\n      matches.push(i);\n    }\n  }\n  return matches;\n}\n\nfunction isPlainObject(obj) {\n  return (\n    Object.prototype.toString.call(obj) === '[object Object]' &&\n    Object.getPrototypeOf(obj) === Object.prototype\n  );\n}\n\nfunction subsetArrayAttrs(obj, indices) {\n  var newObj = {};\n  Object.keys(obj).forEach(function(k) {\n    var val = obj[k];\n\n    if (k.charAt(0) === \"_\") {\n      newObj[k] = val;\n    } else if (k === \"transforms\" && Array.isArray(val)) {\n      newObj[k] = val.map(function(transform) {\n        return subsetArrayAttrs(transform, indices);\n      });\n    } else if (k === \"colorscale\" && Array.isArray(val)) {\n      newObj[k] = val;\n    } else if (isPlainObject(val)) {\n      newObj[k] = subsetArrayAttrs(val, indices);\n    } else if (Array.isArray(val)) {\n      newObj[k] = subsetArray(val, indices);\n    } else {\n      newObj[k] = val;\n    }\n  });\n  return newObj;\n}\n\nfunction subsetArray(arr, indices) {\n  var result = [];\n  for (var i = 0; i < indices.length; i++) {\n    result.push(arr[indices[i]]);\n  }\n  return result;\n}\n\n// Convenience function for removing plotly's brush \nfunction removeBrush(el) {\n  var outlines = el.querySelectorAll(\".select-outline\");\n  for (var i = 0; i < outlines.length; i++) {\n    outlines[i].remove();\n  }\n}\n\n\n// https://davidwalsh.name/javascript-debounce-function\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\nfunction debounce(func, wait, immediate) {\n\tvar timeout;\n\treturn function() {\n\t\tvar context = this, args = arguments;\n\t\tvar later = function() {\n\t\t\ttimeout = null;\n\t\t\tif (!immediate) func.apply(context, args);\n\t\t};\n\t\tvar callNow = immediate && !timeout;\n\t\tclearTimeout(timeout);\n\t\ttimeout = setTimeout(later, wait);\n\t\tif (callNow) func.apply(context, args);\n\t};\n};\n"]}